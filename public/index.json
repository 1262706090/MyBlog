[{"categories":["Note"],"content":"第 一 章 软件测试概述 ","date":"2024-11-30","objectID":"/software-testing/:1:0","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"1.1 软件质量的基本概念 1.1.1 软件危机表现 项目无法按期完成 费用超出预算 质量难以控制 运行难以维护 ","date":"2024-11-30","objectID":"/software-testing/:1:1","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"1.2 软件质量 1.2.3 软件错误 软件错误/软件缺陷（Bug）：计算机程序系统或程序中存在的任何一种破坏正常运行能力的问题、错误或隐藏的功能缺陷、瑕疵。 4 种级别： 致命的：系统整体影响、数据丢失 严重的：主要功能缺陷 一般的：次要功能缺陷 微小的：基本不影响-外观 ","date":"2024-11-30","objectID":"/software-testing/:1:2","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"1.3 软件测试基本知识 1.3.1 软件测试定义 狭义定义：软件测试是为了发现错误而执行程序的过程。 广义定义： 确认：文档 验证：功能 测试：程序 1.3.3 软件测试的辩证观点 正向思维：“工作的”-正确性。 反向思维：“不工作的”-不正确性。 ","date":"2024-11-30","objectID":"/software-testing/:1:3","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"第 二 章 软件测试策略 ","date":"2024-11-30","objectID":"/software-testing/:2:0","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"2.1 软件测试的生命周期 测试顺序：性能测试；可靠性测试；安全性测试。 在软件测试中，将测试的输入数据定义和预期结果的描述记为测试用例。 ","date":"2024-11-30","objectID":"/software-testing/:2:1","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"第 三 章 黑盒测试 特征：把程序或测试看成一个黑盒子，验证输入与输出之间的关系是否正确；不考虑程序内部的结构和特性。 目标：测试程序的功能或接口，检查是否符合需求规格说明书。 ","date":"2024-11-30","objectID":"/software-testing/:3:0","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"3.2 等价类划分测试方法 3.2.4 等价类划分原则 取值范围：一个有效等价类，两个无效等价类 集合或“必须如何”的条件：一个有效等价类，一个无效等价类 布尔量：一个有效等价类，一个无效等价类 一组值（n 个）：n 个有效等价类，一个无效等价类 ","date":"2024-11-30","objectID":"/software-testing/:3:1","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"第 四 章 白盒测试 ","date":"2024-11-30","objectID":"/software-testing/:4:0","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"4.1 静态白盒测试和动态白盒测试 4.1.1 静态白盒测试 不运行软件： 走查、复审、评审程序源代码 检查数据组织、环境设置和软件配置项 4.1.2 动态白盒测试 分析程序代码 设计测试用例 通过驱动程序和桩程序来驱动、调用被测程序的运行 ","date":"2024-11-30","objectID":"/software-testing/:4:1","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"第 五 章 单元测试 5.2.1 角色和职责 ","date":"2024-11-30","objectID":"/software-testing/:5:0","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"第 六 章 集成测试 6.3.1 一次性集成测试 适用场景 被测系统曾经稳定运行 规模不大 构件之间紧密联系 特点 优点：用例少，测试快 缺点：错误定位难，调试难 6.3.2 自顶向下集成测试 适用场景 自顶向下增量式开发 并行式开发 特点 不需要开发驱动模块 桩程序开发工作量比较大 对底层模块的测试不够充分 6.3.3 自底向上集成测试 对底层软件充分测试 6.3.4 协作集成集成测试 尽快测试某些子功能： ","date":"2024-11-30","objectID":"/software-testing/:6:0","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"第 七 章 系统测试 整体软件 除软件本身外，还包含需求分析、概要设计、详细设计、用户使用说明等技术文档 ","date":"2024-11-30","objectID":"/software-testing/:7:0","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"7.3 性能测试 7.3.1 负载压力测试 负载测试：“额定”负载条件（性能极值点之前） 压力测试：“饱和”负载条件（性能极值点之后） ","date":"2024-11-30","objectID":"/software-testing/:7:1","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":"第 八 章 性能测试 ","date":"2024-11-30","objectID":"/software-testing/:8:0","tags":["Software Testing"],"title":"Software Testing","uri":"/software-testing/"},{"categories":["Note"],"content":" 箭头 $$ \\text{存储器（内存、CPU 外）} \\xrightarrow{\\text{数据}} \\text{寄存器（CPU 内）} $$ ","date":"2024-11-25","objectID":"/katex/:0:0","tags":["Math","KaTeX"],"title":"KaTeX笔记","uri":"/katex/"},{"categories":[""],"content":"暂无 ","date":"2024-11-24","objectID":"/about/:0:0","tags":[""],"title":"Index","uri":"/about/"},{"categories":["Note"],"content":"第 1~3 章 基础知识 ","date":"2024-10-01","objectID":"/assembly-language-3rd-edition/:1:0","tags":["Programming-Languages","Assembly Language","Wang Shuang"],"title":"汇编语言（第3版）","uri":"/assembly-language-3rd-edition/"},{"categories":["Note"],"content":"机器语言 由 机器指令（一系列二进制数字）构成。 直接被 CPU 解读执行，是计算机唯一能够理解的语言。 ","date":"2024-10-01","objectID":"/assembly-language-3rd-edition/:1:1","tags":["Programming-Languages","Assembly Language","Wang Shuang"],"title":"汇编语言（第3版）","uri":"/assembly-language-3rd-edition/"},{"categories":["Note"],"content":"汇编语言 概念： 对应机器语言的 低级语言，是机器指令的 助记符形式，便于人类理解。 组成： 汇编指令（主体）： 是机器指令的可读表达形式。 常用格式：操作码 + 操作数（如 MOV AX, 10）。 伪指令： 辅助程序设计的非机器指令，如数据定义、流程控制等。 示例：DB（定义字节数据）。 符号： 标签、变量名等，提升代码可读性。 ","date":"2024-10-01","objectID":"/assembly-language-3rd-edition/:1:2","tags":["Programming-Languages","Assembly Language","Wang Shuang"],"title":"汇编语言（第3版）","uri":"/assembly-language-3rd-edition/"},{"categories":["Note"],"content":"存储器 功能：存储 指令和数据（形式上无区别，均为二进制数）。 特点： 内存：位于 CPU 外部，通过总线与 CPU 通信。 存储单元：每个存储单元存储 1 个字节。 分类： ROM（Read-Only Memory）： 只读存储器，断电后数据不丢失。 常用于存储固件。 RAM（Random Access Memory）： 随机存储器，断电后数据丢失。 主要用作运行程序的临时存储空间。 常见种类： 主板上的内存条。 接口卡上的 RAM：如显卡、网卡上的专用存储器。 ","date":"2024-10-01","objectID":"/assembly-language-3rd-edition/:1:3","tags":["Programming-Languages","Assembly Language","Wang Shuang"],"title":"汇编语言（第3版）","uri":"/assembly-language-3rd-edition/"},{"categories":["Note"],"content":"CPU 对数据和指令的读写 (1) CPU 对数据的读写 三大总线： 地址总线：定位内存地址。 N 根地址总线（宽度为 N），可寻址 $2^N$ 个内存单元。 控制总线：控制操作类型，如读或写。 数据总线：负责数据的传输。 每 8 根数据总线可传输 1 个字节。 (2) 8086 CPU 读取与执行指令的过程 1. 地址计算： CS:IP： CS：段地址（指向当前代码段的基地址）。 IP：偏移地址（指向段内的具体指令位置）。 将 段地址和偏移地址 传递给 地址加法器。 地址加法器计算物理地址： $$ \\text{物理地址} = \\text{段地址} \\times 16 + \\text{偏移地址} $$ 2. 内存访问 地址总线：将计算出的物理地址通过地址总线发送给内存。 控制总线：发出“读”信号，指示内存读取操作。 数据总线：将内存中物理地址对应的指令数据传送到 CPU。 3. 指令缓存 输入输出电路：接收从内存读取的指令数据，并传递到 指令缓冲器。 指令缓冲器：暂时存储读取到的指令，为执行阶段做好准备。 4. 指令执行 执行控制器：从指令缓冲器中获取指令，解码并执行。 $$ \\text{先读取} \\xrightarrow{} \\text{再修改 IP } \\xrightarrow{} \\text{最后执行指令} $$ 执行指令时，IP 已经指向下一条指令。 ","date":"2024-10-01","objectID":"/assembly-language-3rd-edition/:1:4","tags":["Programming-Languages","Assembly Language","Wang Shuang"],"title":"汇编语言（第3版）","uri":"/assembly-language-3rd-edition/"},{"categories":["Note"],"content":"寄存器 (1) 通用寄存器 AX：累加器，常用于算术运算和数据传输，某些指令默认操作对象。 BX：基址寄存器，可存放偏移地址，支持间接寻址（DS:[BX]）。 CX：计数寄存器，主要用于循环和字符串操作中的计数。 DX：数据寄存器，用于扩展乘法和除法操作。 (2) 段寄存器 CS（代码段寄存器）：配合 IP，指向当前代码段的基地址。 DS（数据段寄存器）：指向数据段的基地址，配合偏移地址访问数据。 SS（栈段寄存器）：配合 SP，指向当前栈顶位置。 ES（附加段寄存器）：常用于字符串操作中的附加段，支持段间数据传输。 (3) 指针和索引寄存器 SI：通常用于 BX 的额外寄存。 DI：通常用于 BX 的额外寄存。 BP（基指针寄存器）：与 BX 类似，但默认指向栈段（SS:[BP]）。 ","date":"2024-10-01","objectID":"/assembly-language-3rd-edition/:1:5","tags":["Programming-Languages","Assembly Language","Wang Shuang"],"title":"汇编语言（第3版）","uri":"/assembly-language-3rd-edition/"},{"categories":["Note"],"content":"汇编指令总结 mov：赋值操作 功能：将数据从一个位置传输到另一个位置。 格式：mov 目标, 源。 目标可以是寄存器或内存地址。 源可以是寄存器、内存地址或立即数。 示例：mov AX, 10（将立即数 10 赋值到 AX 寄存器）。 add：加法操作 功能：对两个操作数相加，将结果存入目标操作数。 格式：add 目标, 源。 示例：add AX, 5（将 AX 寄存器的值加 5，结果存入 AX）。 sub：减法操作 功能：对目标操作数减去源操作数，将结果存入目标操作数。 格式：sub 目标, 源。 示例：sub CX, 1（将 CX 的值减 1，结果存入 CX）。 jmp：跳转操作 功能：将程序流程跳转到指定的标号（标签）位置，改变 CS:IP 指针的值。 示例：jmp label（跳转到标号 label 的位置继续执行）。 push：入栈操作 功能： (SP)=(SP)-2 向 SS:SP 指向的字单元送入数据 格式：push 寄存器/内存/立即数。 示例：push CX（将 CX 寄存器的值压入栈中）。 pop：出栈操作 功能： 从 SS:SP 指向的字单元读取数据 (SP)=(SP)+2 格式：pop 寄存器。 示例：pop CX（将栈顶的值弹出，并存入 CX 寄存器）。 loop：循环 功能： (CX)=(CX)-1 判断 CX 中的值，不为 0 跳转，为 0 向下执行 格式：loop 标号。 示例：loop s（跳转到标号）。 and：逻辑与指令，按位进行与运算 功能：置 0 格式：and xxxxxxxxb。 示例：and 11011111b（将第 5 位置 0，小写变大写）。 or：逻辑或指令，按位进行或运算 功能：置 1 格式：or xxxxxxxxb。 示例：or 00100000b（将第 5 位置 1，大写变小写）。 div：除法指令 注意： 除数：8 位/16 位，存在一个 reg 或内存单元中 被除数 除数为 8 位：被除数为 16 位 除数为 16 位： 商、余数 格式：or xxxxxxxxb。 示例：or 00100000b（将第 5 位置 1，大写变小写）。 dup：重复数据 功能：定义多个数据 格式：db 3 dup (0)。 示例：db 3 dup (0)（定义 3 个字节，每个字节的值为 0）。 db：定义字节（define byte） 功能：用于定义 1 个字节，可以定义多个字节。 格式：db \u003cvalue\u003e 或者 db \u003ccount\u003e dup(\u003cvalue\u003e)。 示例：db 3 dup (0)（定义 3 个字节，每个字节的值为 0）。 dw：定义字（define word） 功能：用于定义 1 个字（2 字节），可以定义多个字。 格式：dw \u003cvalue\u003e 或者 dw \u003ccount\u003e dup(\u003cvalue\u003e)。 示例：dw 3 dup (0)（定义 3 个字，每个字的值为 0）。 dd：定义双字（define double word） 功能：用于定义 1 个双字（4 字节），可以定义多个双字。 格式：dd \u003cvalue\u003e 或者 dd \u003ccount\u003e dup(\u003cvalue\u003e)。 示例：dd 3 dup (0)（定义 3 个双字，每个双字的值为 0）。 ","date":"2024-10-01","objectID":"/assembly-language-3rd-edition/:1:6","tags":["Programming-Languages","Assembly Language","Wang Shuang"],"title":"汇编语言（第3版）","uri":"/assembly-language-3rd-edition/"},{"categories":["Note"],"content":"第 4~6 章 汇编程序从写出到执行的过程： 编程（Edit）-\u003e 源程序（xxx.asm）-\u003e 编译（masm） -\u003e 目标文件（xxx.obj）-\u003e 连接（link）-\u003e 可执行文件（程序、相关描述信息）（xxx.exe）-\u003e 加载（command）-\u003e 内存中的程序-\u003e 运行（CPU） ","date":"2024-10-01","objectID":"/assembly-language-3rd-edition/:2:0","tags":["Programming-Languages","Assembly Language","Wang Shuang"],"title":"汇编语言（第3版）","uri":"/assembly-language-3rd-edition/"},{"categories":["Note"],"content":"第 7~8 章 寻址方式综合应用：[bx].10h[si] 在没有寄存器参与的内存访问指令中，使用操作符 X ptr 指明内存单元长度： word ptr byte ptr ","date":"2024-10-01","objectID":"/assembly-language-3rd-edition/:3:0","tags":["Programming-Languages","Assembly Language","Wang Shuang"],"title":"汇编语言（第3版）","uri":"/assembly-language-3rd-edition/"}]